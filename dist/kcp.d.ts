/// <reference types="node" />
export declare const IKCP_RTO_NDL = 30;
export declare const IKCP_RTO_MIN = 100;
export declare const IKCP_RTO_DEF = 200;
export declare const IKCP_RTO_MAX = 60000;
export declare const IKCP_CMD_PUSH = 81;
export declare const IKCP_CMD_ACK = 82;
export declare const IKCP_CMD_WASK = 83;
export declare const IKCP_CMD_WINS = 84;
export declare const IKCP_ASK_SEND = 1;
export declare const IKCP_ASK_TELL = 2;
export declare const IKCP_WND_SND = 32;
export declare const IKCP_WND_RCV = 32;
export declare const IKCP_MTU_DEF = 1400;
export declare const IKCP_ACK_FAST = 3;
export declare const IKCP_INTERVAL = 100;
export declare const IKCP_OVERHEAD = 24;
export declare const IKCP_DEADLINK = 20;
export declare const IKCP_THRESH_INIT = 2;
export declare const IKCP_THRESH_MIN = 2;
export declare const IKCP_PROBE_INIT = 7000;
export declare const IKCP_PROBE_LIMIT = 120000;
export declare const IKCP_SN_OFFSET = 12;
declare class Segment {
    conv: number;
    cmd: number;
    frg: number;
    wnd: number;
    ts: number;
    sn: number;
    una: number;
    rto: number;
    xmit: number;
    resendts: number;
    fastack: number;
    acked: number;
    data: Buffer;
    constructor(size?: number);
    encode(ptr: Buffer): Buffer;
}
declare class AckItem {
    sn: number;
    ts: number;
}
type output_callback = (buf: Buffer, len: number, user: any) => void;
export declare class Kcp {
    conv: number;
    mtu: number;
    mss: number;
    state: number;
    snd_una: number;
    snd_nxt: number;
    rcv_nxt: number;
    ts_recent: number;
    ts_lastack: number;
    ssthresh: number;
    rx_rttvar: number;
    rx_srtt: number;
    rx_rto: number;
    rx_minrto: number;
    snd_wnd: number;
    rcv_wnd: number;
    rmt_wnd: number;
    cwnd: number;
    probe: number;
    interval: number;
    ts_flush: number;
    xmit: number;
    nodelay: number;
    updated: number;
    ts_probe: number;
    probe_wait: number;
    dead_link: number;
    incr: number;
    snd_queue: Segment[];
    rcv_queue: Segment[];
    snd_buf: Segment[];
    rcv_buf: Segment[];
    acklist: AckItem[];
    ackcount: number;
    ackblock: number;
    buffer: Buffer;
    fastresend: number;
    nocwnd: number;
    stream: number;
    user: any;
    output: output_callback;
    reserved: number;
    constructor(conv: number, user: any);
    private _delSegment;
    setWndSize(sndwnd: number, rcvwnd: number): number;
    setMtu(mtu: number): number;
    setNoDelay(nodelay: number, interval: number, resend: number, nc: number): number;
    release(): void;
    context(): any;
    recv(buffer: Buffer): number;
    input(data: Buffer, regular: boolean, ackNodelay: boolean): number;
    private _parse_una;
    private _shrink_buf;
    private _parse_ack;
    private _parse_fastack;
    private _parse_data;
    private _update_ack;
    private _ack_push;
    send(buffer: Buffer): number;
    setOutput(output: output_callback): void;
    update(): void;
    check(): number;
    private _wnd_unused;
    flush(ackOnly: boolean): number;
    peekSize(): number;
    getWaitSnd(): number;
    setReserveBytes(len: number): boolean;
}
export {};
